index,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,target,vul_func_with_fix,processed_func,flaw_line,flaw_line_index
73752,None,Remote,Not required,Complete,CVE-2016-6561,https://www.cvedetails.com/cve/CVE-2016-6561/,CWE-476,Low,None,None,,2017-03-31,7.8,illumos smbsrv NULL pointer dereference allows system crash.,2017-05-01,,0,https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799,6d1c73b5858fefc6161c7d686345f0dc887ea799,"7483 SMB flush on pipe triggers NULL pointer dereference in module smbsrv
Reviewed by: Gordon Ross <gwr@nexenta.com>
Reviewed by: Matt Barden <matt.barden@nexenta.com>
Reviewed by: Evan Layton <evan.layton@nexenta.com>
Reviewed by: Dan McDonald <danmcd@omniti.com>
Approved by: Gordon Ross <gwr@nexenta.com>",0,usr/src/uts/common/fs/smbsrv/smb_ofile.c,"{""sha"": ""82263d59366b6880a932b04f7a054a273e5a2169"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 8, ""changes"": 10, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb2_flush.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -11,6 +11,7 @@\n \n /*\n  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -23,7 +24,6 @@\n smb_sdrc_t\n smb2_flush(smb_request_t *sr)\n {\n-\tsmb_ofile_t *of = NULL;\n \tuint16_t StructSize;\n \tuint16_t reserved1;\n \tuint32_t reserved2;\n@@ -51,14 +51,8 @@ smb2_flush(smb_request_t *sr)\n \t\tsmb2sr_put_error(sr, status);\n \t\treturn (SDRC_SUCCESS);\n \t}\n-\tof = sr->fid_ofile;\n \n-\t/*\n-\t * XXX - todo:\n-\t * Flush named pipe should drain writes.\n-\t */\n-\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\tsmb_ofile_flush(sr, sr->fid_ofile);\n \n \t/*\n \t * SMB2 Flush reply""}<_**next**_>{""sha"": ""1d210c3d8990d77683b7c5ca69ea67fe338c129c"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 21, ""changes"": 25, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb_flush.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -21,6 +21,8 @@\n /*\n  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n  * Use is subject to license terms.\n+ *\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -40,8 +42,6 @@\n #include <smbsrv/smb_fsops.h>\n \n \n-static void smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile);\n-\n /*\n  * smb_com_flush\n  *\n@@ -90,15 +90,14 @@ smb_com_flush(smb_request_t *sr)\n \t\t\t    ERRDOS, ERRbadfid);\n \t\t\treturn (SDRC_ERROR);\n \t\t}\n-\n-\t\tsmb_flush_file(sr, sr->fid_ofile);\n+\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n \t} else {\n \t\tflist = &sr->tid_tree->t_ofile_list;\n \t\tsmb_llist_enter(flist, RW_READER);\n \t\tfile = smb_llist_head(flist);\n \t\twhile (file) {\n \t\t\tmutex_enter(&file->f_mutex);\n-\t\t\tsmb_flush_file(sr, file);\n+\t\t\tsmb_ofile_flush(sr, file);\n \t\t\tmutex_exit(&file->f_mutex);\n \t\t\tfile = smb_llist_next(flist, file);\n \t\t}\n@@ -108,19 +107,3 @@ smb_com_flush(smb_request_t *sr)\n \trc = smbsr_encode_empty_result(sr);\n \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n }\n-\n-\n-/*\n- * smb_flush_file\n- *\n- * If writes on this file are not synchronous, flush it using the NFSv3\n- * commit interface.\n- */\n-static void\n-smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n-{\n-\tsr->user_cr = smb_ofile_getcred(ofile);\n-\n-\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n-}""}<_**next**_>{""sha"": ""582091d1dd645238651551fb71c024bddd1d27d5"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb_ofile.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -21,6 +21,7 @@\n /*\n  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -836,6 +837,27 @@ smb_ofile_seek(\n \treturn (rc);\n }\n \n+/*\n+ * smb_ofile_flush\n+ *\n+ * If writes on this file are not synchronous, flush it using the NFSv3\n+ * commit interface.\n+ *\n+ * XXX - todo: Flush named pipe should drain writes.\n+ */\n+void\n+smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n+{\n+\tswitch (of->f_ftype) {\n+\tcase SMB_FTYPE_DISK:\n+\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n+\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n /*\n  * smb_ofile_is_open\n  */""}<_**next**_>{""sha"": ""2dd8787aebfd3af6f5a5fb3a345e26ef697b68a5"", ""filename"": ""usr/src/uts/common/smbsrv/smb_kproto.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/smbsrv/smb_kproto.h"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/smbsrv/smb_kproto.h"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/smbsrv/smb_kproto.h?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -22,6 +22,7 @@\n /*\n  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L.  All rights reserved.\n  */\n \n /*\n@@ -673,6 +674,7 @@ void smb_ofile_close(smb_ofile_t *, int32_t);\n void smb_ofile_delete(void *);\n uint32_t smb_ofile_access(smb_ofile_t *, cred_t *, uint32_t);\n int smb_ofile_seek(smb_ofile_t *, ushort_t, int32_t, uint32_t *);\n+void smb_ofile_flush(smb_request_t *, smb_ofile_t *);\n boolean_t smb_ofile_hold(smb_ofile_t *);\n void smb_ofile_release(smb_ofile_t *);\n void smb_ofile_request_complete(smb_ofile_t *);""}","smb_ofile_delete(void *arg)
{
	smb_tree_t	*tree;
	smb_ofile_t	*of = (smb_ofile_t *)arg;

	SMB_OFILE_VALID(of);
	ASSERT(of->f_refcnt == 0);
	ASSERT(of->f_state == SMB_OFILE_STATE_CLOSED);
	ASSERT(!SMB_OFILE_OPLOCK_GRANTED(of));

	tree = of->f_tree;
	smb_llist_enter(&tree->t_ofile_list, RW_WRITER);
	smb_llist_remove(&tree->t_ofile_list, of);
	smb_idpool_free(&tree->t_fid_pool, of->f_fid);
	atomic_dec_32(&tree->t_session->s_file_cnt);
	smb_llist_exit(&tree->t_ofile_list);

	mutex_enter(&of->f_mutex);
	mutex_exit(&of->f_mutex);

	switch (of->f_ftype) {
	case SMB_FTYPE_BYTE_PIPE:
	case SMB_FTYPE_MESG_PIPE:
		smb_opipe_dealloc(of->f_pipe);
		of->f_pipe = NULL;
		break;
	case SMB_FTYPE_DISK:
		if (of->f_odir != NULL)
			smb_odir_release(of->f_odir);
		smb_node_rem_ofile(of->f_node, of);
		smb_node_release(of->f_node);
		break;
	default:
		ASSERT(!""f_ftype"");
		break;
	}

	of->f_magic = (uint32_t)~SMB_OFILE_MAGIC;
	mutex_destroy(&of->f_mutex);
	crfree(of->f_cr);
	smb_user_release(of->f_user);
	kmem_cache_free(smb_cache_ofile, of);
}
","smb_ofile_delete(void *arg)
{
	smb_tree_t	*tree;
	smb_ofile_t	*of = (smb_ofile_t *)arg;

	SMB_OFILE_VALID(of);
	ASSERT(of->f_refcnt == 0);
	ASSERT(of->f_state == SMB_OFILE_STATE_CLOSED);
	ASSERT(!SMB_OFILE_OPLOCK_GRANTED(of));

	tree = of->f_tree;
	smb_llist_enter(&tree->t_ofile_list, RW_WRITER);
	smb_llist_remove(&tree->t_ofile_list, of);
	smb_idpool_free(&tree->t_fid_pool, of->f_fid);
	atomic_dec_32(&tree->t_session->s_file_cnt);
	smb_llist_exit(&tree->t_ofile_list);

	mutex_enter(&of->f_mutex);
	mutex_exit(&of->f_mutex);

	switch (of->f_ftype) {
	case SMB_FTYPE_BYTE_PIPE:
	case SMB_FTYPE_MESG_PIPE:
		smb_opipe_dealloc(of->f_pipe);
		of->f_pipe = NULL;
		break;
	case SMB_FTYPE_DISK:
		if (of->f_odir != NULL)
			smb_odir_release(of->f_odir);
		smb_node_rem_ofile(of->f_node, of);
		smb_node_release(of->f_node);
		break;
	default:
		ASSERT(!""f_ftype"");
		break;
	}

	of->f_magic = (uint32_t)~SMB_OFILE_MAGIC;
	mutex_destroy(&of->f_mutex);
	crfree(of->f_cr);
	smb_user_release(of->f_user);
	kmem_cache_free(smb_cache_ofile, of);
}
",C,,,,"@@ -21,6 +21,7 @@
 /*
  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2016 Syneto S.R.L. All rights reserved.
  */
 
 /*
@@ -836,6 +837,27 @@ smb_ofile_seek(
 	return (rc);
 }
 
+/*
+ * smb_ofile_flush
+ *
+ * If writes on this file are not synchronous, flush it using the NFSv3
+ * commit interface.
+ *
+ * XXX - todo: Flush named pipe should drain writes.
+ */
+void
+smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)
+{
+	switch (of->f_ftype) {
+	case SMB_FTYPE_DISK:
+		if ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
+			(void) smb_fsop_commit(sr, of->f_cr, of->f_node);
+		break;
+	default:
+		break;
+	}
+}
+
 /*
  * smb_ofile_is_open
  */",illumos-gate,6d1c73b5858fefc6161c7d686345f0dc887ea799,516627f338a630bcf9806a91aa873bbbae9a2fac,0,"smb_ofile_delete(void *arg)
{
	smb_tree_t	*tree;
	smb_ofile_t	*of = (smb_ofile_t *)arg;

	SMB_OFILE_VALID(of);
	ASSERT(of->f_refcnt == 0);
	ASSERT(of->f_state == SMB_OFILE_STATE_CLOSED);
	ASSERT(!SMB_OFILE_OPLOCK_GRANTED(of));

	tree = of->f_tree;
	smb_llist_enter(&tree->t_ofile_list, RW_WRITER);
	smb_llist_remove(&tree->t_ofile_list, of);
	smb_idpool_free(&tree->t_fid_pool, of->f_fid);
	atomic_dec_32(&tree->t_session->s_file_cnt);
	smb_llist_exit(&tree->t_ofile_list);

	mutex_enter(&of->f_mutex);
	mutex_exit(&of->f_mutex);

	switch (of->f_ftype) {
	case SMB_FTYPE_BYTE_PIPE:
	case SMB_FTYPE_MESG_PIPE:
		smb_opipe_dealloc(of->f_pipe);
		of->f_pipe = NULL;
		break;
	case SMB_FTYPE_DISK:
		if (of->f_odir != NULL)
			smb_odir_release(of->f_odir);
		smb_node_rem_ofile(of->f_node, of);
		smb_node_release(of->f_node);
		break;
	default:
		ASSERT(!""f_ftype"");
		break;
	}

	of->f_magic = (uint32_t)~SMB_OFILE_MAGIC;
	mutex_destroy(&of->f_mutex);
	crfree(of->f_cr);
	smb_user_release(of->f_user);
	kmem_cache_free(smb_cache_ofile, of);
}
","smb_ofile_delete(void *arg)
{
	smb_tree_t	*tree;
	smb_ofile_t	*of = (smb_ofile_t *)arg;

	SMB_OFILE_VALID(of);
	ASSERT(of->f_refcnt == 0);
	ASSERT(of->f_state == SMB_OFILE_STATE_CLOSED);
	ASSERT(!SMB_OFILE_OPLOCK_GRANTED(of));

	tree = of->f_tree;
	smb_llist_enter(&tree->t_ofile_list, RW_WRITER);
	smb_llist_remove(&tree->t_ofile_list, of);
	smb_idpool_free(&tree->t_fid_pool, of->f_fid);
	atomic_dec_32(&tree->t_session->s_file_cnt);
	smb_llist_exit(&tree->t_ofile_list);

	mutex_enter(&of->f_mutex);
	mutex_exit(&of->f_mutex);

	switch (of->f_ftype) {
	case SMB_FTYPE_BYTE_PIPE:
	case SMB_FTYPE_MESG_PIPE:
		smb_opipe_dealloc(of->f_pipe);
		of->f_pipe = NULL;
		break;
	case SMB_FTYPE_DISK:
		if (of->f_odir != NULL)
			smb_odir_release(of->f_odir);
		smb_node_rem_ofile(of->f_node, of);
		smb_node_release(of->f_node);
		break;
	default:
		ASSERT(!""f_ftype"");
		break;
	}

	of->f_magic = (uint32_t)~SMB_OFILE_MAGIC;
	mutex_destroy(&of->f_mutex);
	crfree(of->f_cr);
	smb_user_release(of->f_user);
	kmem_cache_free(smb_cache_ofile, of);
}
",,
54196,None,Local,Not required,Complete,CVE-2016-3138,https://www.cvedetails.com/cve/CVE-2016-3138/,,Low,None,None,,2016-05-02,4.9,The acm_probe function in drivers/usb/class/cdc-acm.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both a control and a data endpoint descriptor.,2016-11-30,DoS ,0,https://github.com/torvalds/linux/commit/8835ba4a39cf53f705417b3b3a94eb067673f2c9,8835ba4a39cf53f705417b3b3a94eb067673f2c9,"USB: cdc-acm: more sanity checking

An attack has become available which pretends to be a quirky
device circumventing normal sanity checks and crashes the kernel
by an insufficient number of interfaces. This patch adds a check
to the code path for quirky devices.

Signed-off-by: Oliver Neukum <ONeukum@suse.com>
CC: stable@vger.kernel.org
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",0,drivers/usb/class/cdc-acm.c,"{""sha"": ""83fd30b0577c55f33eace402617ff3a2a4b09126"", ""filename"": ""drivers/usb/class/cdc-acm.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/8835ba4a39cf53f705417b3b3a94eb067673f2c9/drivers/usb/class/cdc-acm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8835ba4a39cf53f705417b3b3a94eb067673f2c9/drivers/usb/class/cdc-acm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/class/cdc-acm.c?ref=8835ba4a39cf53f705417b3b3a94eb067673f2c9"", ""patch"": ""@@ -1179,6 +1179,9 @@ static int acm_probe(struct usb_interface *intf,\n \tif (quirks == NO_UNION_NORMAL) {\n \t\tdata_interface = usb_ifnum_to_if(usb_dev, 1);\n \t\tcontrol_interface = usb_ifnum_to_if(usb_dev, 0);\n+\t\t/* we would crash */\n+\t\tif (!data_interface || !control_interface)\n+\t\t\treturn -ENODEV;\n \t\tgoto skip_normal_probe;\n \t}\n ""}","static inline int acm_set_control(struct acm *acm, int control)
{
	if (acm->quirks & QUIRK_CONTROL_LINE_STATE)
		return -EOPNOTSUPP;

	return acm_ctrl_msg(acm, USB_CDC_REQ_SET_CONTROL_LINE_STATE,
			control, NULL, 0);
}
","static inline int acm_set_control(struct acm *acm, int control)
{
	if (acm->quirks & QUIRK_CONTROL_LINE_STATE)
		return -EOPNOTSUPP;

	return acm_ctrl_msg(acm, USB_CDC_REQ_SET_CONTROL_LINE_STATE,
			control, NULL, 0);
}
",C,,,,"@@ -1179,6 +1179,9 @@ static int acm_probe(struct usb_interface *intf,
 	if (quirks == NO_UNION_NORMAL) {
 		data_interface = usb_ifnum_to_if(usb_dev, 1);
 		control_interface = usb_ifnum_to_if(usb_dev, 0);
+		/* we would crash */
+		if (!data_interface || !control_interface)
+			return -ENODEV;
 		goto skip_normal_probe;
 	}
 ",linux,8835ba4a39cf53f705417b3b3a94eb067673f2c9,0b818e3956fc1ad976bee791eadcbb3b5fec5bfd,0,"static inline int acm_set_control(struct acm *acm, int control)
{
	if (acm->quirks & QUIRK_CONTROL_LINE_STATE)
		return -EOPNOTSUPP;

	return acm_ctrl_msg(acm, USB_CDC_REQ_SET_CONTROL_LINE_STATE,
			control, NULL, 0);
}
","static inline int acm_set_control(struct acm *acm, int control)
{
	if (acm->quirks & QUIRK_CONTROL_LINE_STATE)
		return -EOPNOTSUPP;

	return acm_ctrl_msg(acm, USB_CDC_REQ_SET_CONTROL_LINE_STATE,
			control, NULL, 0);
}
",,
169124,None,Remote,Not required,None,CVE-2018-6145,https://www.cvedetails.com/cve/CVE-2018-6145/,CWE-79,Medium,None,Partial,,2019-06-27,4.3,Insufficient data validation in HTML parser in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to bypass same origin policy via a crafted HTML page.,2019-07-02,XSS Bypass ,0,https://github.com/chromium/chromium/commit/133bc5c262b2555af223263452e9875a95db9eb7,133bc5c262b2555af223263452e9875a95db9eb7,"HTML parser: Fix ""HTML integration point"" implementation in HTMLTreeBuilderSimulator.

HTMLTreeBuilderSimulator assumed only <foreignObject> as an HTML
integration point. This CL adds <annotation-xml>, <desc>, and SVG
<title>.

Bug: 805924
Change-Id: I6793d9163d4c6bc8bf0790415baedddaac7a1fc2
Reviewed-on: https://chromium-review.googlesource.com/964038
Commit-Queue: Kent Tamura <tkent@chromium.org>
Reviewed-by: Kouhei Ueno <kouhei@chromium.org>
Cr-Commit-Position: refs/heads/master@{#543634}",0,third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp,"{""sha"": ""be6b42d07d0257fcc2ffc13401be3777395a02fb"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""status"": ""added"", ""additions"": 31, ""deletions"": 0, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/html/syntax/parsing/html-integration-point.html?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -0,0 +1,31 @@\n+<!DOCTYPE html>\n+<link rel=\""help\"" href=\""https://html.spec.whatwg.org/multipage/parsing.html#tree-construction:html-integration-point\"">\n+<body>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<math><annotation-xml id=\""point-1\"" encoding=\""text/html\""><xmp>&lt;/xmp&gt;&lt;img></xmp></annotation-xml></math>\n+<math><annotation-xml id=\""point-2\"" encoding=\""application/xhtml+xml\""><style>&lt;/style&gt;&lt;img></style></annotation-xml></math>\n+<svg><foreignObject id=\""point-3\""><iframe>&lt;/iframe&gt;&lt;img></iframe></foreignObject></svg>\n+<svg><desc id=\""point-4\""><noembed>&lt;/noembed&gt;&lt;img></noembed></desc></svg>\n+<svg><title id=\""point-5\""><noframes>&lt;/noframes&gt;&lt;img></noframes></title></svg>\n+\n+<script>\n+function generate_test(id) {\n+  return () => {\n+    let point = document.querySelector('#' + id);\n+    assert_not_equals(point.namespaceURI, 'http://www.w3.org/1999/xhtml');\n+    let rawTextElement = point.firstChild;\n+    assert_equals(rawTextElement.namespaceURI, 'http://www.w3.org/1999/xhtml');\n+    assert_equals(rawTextElement.textContent.substr(0, 4), '&lt;',\n+                  'Entity references should not be decoded.');\n+  };\n+}\n+\n+test(generate_test('point-1'), 'MathML annotation-xml with encoding=text/html should be an HTML integration point');\n+test(generate_test('point-2'), 'MathML annotation-xml with encoding=application/xhtml+xml should be an HTML integration point');\n+test(generate_test('point-3'), 'SVG foreignObject should be an HTML integration point');\n+test(generate_test('point-4'), 'SVG desc should be an HTML integration point');\n+test(generate_test('point-5'), 'SVG title should be an HTML integration point');\n+</script>\n+</body>""}<_**next**_>{""sha"": ""1029c22a1afb3ea6dfc12e98952ba2e98302ef03"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""status"": ""modified"", ""additions"": 59, ""deletions"": 12, ""changes"": 71, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.cpp?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -82,13 +82,6 @@ static bool TokenExitsForeignContent(const CompactHTMLToken& token) {\n            token.GetAttributeItem(sizeAttr)));\n }\n \n-static bool TokenExitsSVG(const CompactHTMLToken& token) {\n-  // FIXME: It's very fragile that we special case foreignObject here to be\n-  // case-insensitive.\n-  return DeprecatedEqualIgnoringCase(token.Data(),\n-                                     SVGNames::foreignObjectTag.LocalName());\n-}\n-\n static bool TokenExitsMath(const CompactHTMLToken& token) {\n   // FIXME: This is copied from HTMLElementStack::isMathMLTextIntegrationPoint\n   // and changed to use threadSafeMatch.\n@@ -148,10 +141,10 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n       namespace_stack_.push_back(kMathML);\n     if (InForeignContent() && TokenExitsForeignContent(token))\n       namespace_stack_.pop_back();\n-    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||\n-        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))\n+    if (IsHTMLIntegrationPointForStartTag(token) ||\n+        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {\n       namespace_stack_.push_back(HTML);\n-    if (!InForeignContent()) {\n+    } else if (!InForeignContent()) {\n       // FIXME: This is just a copy of Tokenizer::updateStateFor which uses\n       // threadSafeMatches.\n       if (ThreadSafeMatch(tag_name, textareaTag) ||\n@@ -203,8 +196,7 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||\n         (namespace_stack_.back() == kMathML &&\n          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||\n-        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&\n-         TokenExitsSVG(token)) ||\n+        IsHTMLIntegrationPointForEndTag(token) ||\n         (namespace_stack_.Contains(kMathML) &&\n          namespace_stack_.back() == HTML && TokenExitsMath(token))) {\n       namespace_stack_.pop_back();\n@@ -226,4 +218,59 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(\n   return simulated_token;\n }\n \n+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point\n+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForStartTag(\n+    const CompactHTMLToken& token) const {\n+  DCHECK(token.GetType() == HTMLToken::kStartTag) << token.GetType();\n+\n+  Namespace tokens_ns = namespace_stack_.back();\n+  const String& tag_name = token.Data();\n+  if (tokens_ns == kMathML) {\n+    if (!ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag))\n+      return false;\n+    if (auto* encoding = token.GetAttributeItem(MathMLNames::encodingAttr)) {\n+      return EqualIgnoringASCIICase(encoding->Value(), \""text/html\"") ||\n+             EqualIgnoringASCIICase(encoding->Value(), \""application/xhtml+xml\"");\n+    }\n+  } else if (tokens_ns == SVG) {\n+    // FIXME: It's very fragile that we special case foreignObject here to be\n+    // case-insensitive.\n+    if (DeprecatedEqualIgnoringCase(tag_name,\n+                                    SVGNames::foreignObjectTag.LocalName()))\n+      return true;\n+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||\n+           ThreadSafeMatch(tag_name, SVGNames::titleTag);\n+  }\n+  return false;\n+}\n+\n+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point\n+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForEndTag(\n+    const CompactHTMLToken& token) const {\n+  if (token.GetType() != HTMLToken::kEndTag)\n+    return false;\n+\n+  // If it's inside an HTML integration point, the top namespace is\n+  // HTML, and its next namespace is not HTML.\n+  if (namespace_stack_.back() != HTML)\n+    return false;\n+  if (namespace_stack_.size() < 2)\n+    return false;\n+  Namespace tokens_ns = namespace_stack_[namespace_stack_.size() - 2];\n+\n+  const String& tag_name = token.Data();\n+  if (tokens_ns == kMathML)\n+    return ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag);\n+  if (tokens_ns == SVG) {\n+    // FIXME: It's very fragile that we special case foreignObject here to be\n+    // case-insensitive.\n+    if (DeprecatedEqualIgnoringCase(tag_name,\n+                                    SVGNames::foreignObjectTag.LocalName()))\n+      return true;\n+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||\n+           ThreadSafeMatch(tag_name, SVGNames::titleTag);\n+  }\n+  return false;\n+}\n+\n }  // namespace blink""}<_**next**_>{""sha"": ""2fd9f921ce33ccc4daf367f1ce3f793e78617521"", ""filename"": ""third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/133bc5c262b2555af223263452e9875a95db9eb7/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/HTMLTreeBuilderSimulator.h?ref=133bc5c262b2555af223263452e9875a95db9eb7"", ""patch"": ""@@ -64,6 +64,8 @@ class CORE_EXPORT HTMLTreeBuilderSimulator {\n \n  private:\n   bool InForeignContent() const { return namespace_stack_.back() != HTML; }\n+  bool IsHTMLIntegrationPointForStartTag(const CompactHTMLToken&) const;\n+  bool IsHTMLIntegrationPointForEndTag(const CompactHTMLToken&) const;\n \n   HTMLParserOptions options_;\n   State namespace_stack_;""}","HTMLTreeBuilderSimulator::State HTMLTreeBuilderSimulator::StateFor(
    HTMLTreeBuilder* tree_builder) {
  DCHECK(IsMainThread());
  State namespace_stack;
  for (HTMLElementStack::ElementRecord* record =
           tree_builder->OpenElements()->TopRecord();
       record; record = record->Next()) {
    Namespace current_namespace = HTML;
    if (record->NamespaceURI() == SVGNames::svgNamespaceURI)
      current_namespace = SVG;
    else if (record->NamespaceURI() == MathMLNames::mathmlNamespaceURI)
      current_namespace = kMathML;

    if (namespace_stack.IsEmpty() ||
        namespace_stack.back() != current_namespace)
      namespace_stack.push_back(current_namespace);
  }
  namespace_stack.Reverse();
  return namespace_stack;
}
","HTMLTreeBuilderSimulator::State HTMLTreeBuilderSimulator::StateFor(
    HTMLTreeBuilder* tree_builder) {
  DCHECK(IsMainThread());
  State namespace_stack;
  for (HTMLElementStack::ElementRecord* record =
           tree_builder->OpenElements()->TopRecord();
       record; record = record->Next()) {
    Namespace current_namespace = HTML;
    if (record->NamespaceURI() == SVGNames::svgNamespaceURI)
      current_namespace = SVG;
    else if (record->NamespaceURI() == MathMLNames::mathmlNamespaceURI)
      current_namespace = kMathML;

    if (namespace_stack.IsEmpty() ||
        namespace_stack.back() != current_namespace)
      namespace_stack.push_back(current_namespace);
  }
  namespace_stack.Reverse();
  return namespace_stack;
}
",C,,,,"@@ -82,13 +82,6 @@ static bool TokenExitsForeignContent(const CompactHTMLToken& token) {
            token.GetAttributeItem(sizeAttr)));
 }
 
-static bool TokenExitsSVG(const CompactHTMLToken& token) {
-  // FIXME: It's very fragile that we special case foreignObject here to be
-  // case-insensitive.
-  return DeprecatedEqualIgnoringCase(token.Data(),
-                                     SVGNames::foreignObjectTag.LocalName());
-}
-
 static bool TokenExitsMath(const CompactHTMLToken& token) {
   // FIXME: This is copied from HTMLElementStack::isMathMLTextIntegrationPoint
   // and changed to use threadSafeMatch.
@@ -148,10 +141,10 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
       namespace_stack_.push_back(kMathML);
     if (InForeignContent() && TokenExitsForeignContent(token))
       namespace_stack_.pop_back();
-    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||
-        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))
+    if (IsHTMLIntegrationPointForStartTag(token) ||
+        (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {
       namespace_stack_.push_back(HTML);
-    if (!InForeignContent()) {
+    } else if (!InForeignContent()) {
       // FIXME: This is just a copy of Tokenizer::updateStateFor which uses
       // threadSafeMatches.
       if (ThreadSafeMatch(tag_name, textareaTag) ||
@@ -203,8 +196,7 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
          ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||
         (namespace_stack_.back() == kMathML &&
          ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||
-        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&
-         TokenExitsSVG(token)) ||
+        IsHTMLIntegrationPointForEndTag(token) ||
         (namespace_stack_.Contains(kMathML) &&
          namespace_stack_.back() == HTML && TokenExitsMath(token))) {
       namespace_stack_.pop_back();
@@ -226,4 +218,59 @@ HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
   return simulated_token;
 }
 
+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point
+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForStartTag(
+    const CompactHTMLToken& token) const {
+  DCHECK(token.GetType() == HTMLToken::kStartTag) << token.GetType();
+
+  Namespace tokens_ns = namespace_stack_.back();
+  const String& tag_name = token.Data();
+  if (tokens_ns == kMathML) {
+    if (!ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag))
+      return false;
+    if (auto* encoding = token.GetAttributeItem(MathMLNames::encodingAttr)) {
+      return EqualIgnoringASCIICase(encoding->Value(), ""text/html"") ||
+             EqualIgnoringASCIICase(encoding->Value(), ""application/xhtml+xml"");
+    }
+  } else if (tokens_ns == SVG) {
+    // FIXME: It's very fragile that we special case foreignObject here to be
+    // case-insensitive.
+    if (DeprecatedEqualIgnoringCase(tag_name,
+                                    SVGNames::foreignObjectTag.LocalName()))
+      return true;
+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||
+           ThreadSafeMatch(tag_name, SVGNames::titleTag);
+  }
+  return false;
+}
+
+// https://html.spec.whatwg.org/multipage/parsing.html#html-integration-point
+bool HTMLTreeBuilderSimulator::IsHTMLIntegrationPointForEndTag(
+    const CompactHTMLToken& token) const {
+  if (token.GetType() != HTMLToken::kEndTag)
+    return false;
+
+  // If it's inside an HTML integration point, the top namespace is
+  // HTML, and its next namespace is not HTML.
+  if (namespace_stack_.back() != HTML)
+    return false;
+  if (namespace_stack_.size() < 2)
+    return false;
+  Namespace tokens_ns = namespace_stack_[namespace_stack_.size() - 2];
+
+  const String& tag_name = token.Data();
+  if (tokens_ns == kMathML)
+    return ThreadSafeMatch(tag_name, MathMLNames::annotation_xmlTag);
+  if (tokens_ns == SVG) {
+    // FIXME: It's very fragile that we special case foreignObject here to be
+    // case-insensitive.
+    if (DeprecatedEqualIgnoringCase(tag_name,
+                                    SVGNames::foreignObjectTag.LocalName()))
+      return true;
+    return ThreadSafeMatch(tag_name, SVGNames::descTag) ||
+           ThreadSafeMatch(tag_name, SVGNames::titleTag);
+  }
+  return false;
+}
+
 }  // namespace blink",Chrome,133bc5c262b2555af223263452e9875a95db9eb7,1e8327c88920544f1503004b4e32850c935d4efb,0,"HTMLTreeBuilderSimulator::State HTMLTreeBuilderSimulator::StateFor(
    HTMLTreeBuilder* tree_builder) {
  DCHECK(IsMainThread());
  State namespace_stack;
  for (HTMLElementStack::ElementRecord* record =
           tree_builder->OpenElements()->TopRecord();
       record; record = record->Next()) {
    Namespace current_namespace = HTML;
    if (record->NamespaceURI() == SVGNames::svgNamespaceURI)
      current_namespace = SVG;
    else if (record->NamespaceURI() == MathMLNames::mathmlNamespaceURI)
      current_namespace = kMathML;

    if (namespace_stack.IsEmpty() ||
        namespace_stack.back() != current_namespace)
      namespace_stack.push_back(current_namespace);
  }
  namespace_stack.Reverse();
  return namespace_stack;
}
","HTMLTreeBuilderSimulator::State HTMLTreeBuilderSimulator::StateFor(
    HTMLTreeBuilder* tree_builder) {
  DCHECK(IsMainThread());
  State namespace_stack;
  for (HTMLElementStack::ElementRecord* record =
           tree_builder->OpenElements()->TopRecord();
       record; record = record->Next()) {
    Namespace current_namespace = HTML;
    if (record->NamespaceURI() == SVGNames::svgNamespaceURI)
      current_namespace = SVG;
    else if (record->NamespaceURI() == MathMLNames::mathmlNamespaceURI)
      current_namespace = kMathML;

    if (namespace_stack.IsEmpty() ||
        namespace_stack.back() != current_namespace)
      namespace_stack.push_back(current_namespace);
  }
  namespace_stack.Reverse();
  return namespace_stack;
}
",,
109551,None,Remote,Not required,Partial,CVE-2012-5135,https://www.cvedetails.com/cve/CVE-2012-5135/,CWE-399,Low,Partial,Partial,,2012-11-27,7.5,Use-after-free vulnerability in Google Chrome before 23.0.1271.91 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to printing.,2018-10-30,DoS ,0,https://github.com/chromium/chromium/commit/b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6,b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6,"Guard against the same PrintWebViewHelper being re-entered.

BUG=159165

Review URL: https://chromiumcodereview.appspot.com/11367076

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@165821 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/renderer/print_web_view_helper.cc,"{""sha"": ""3aff7532eb6c8b3bec82fe0c6c102b54834f6db0"", ""filename"": ""chrome/renderer/print_web_view_helper.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6/chrome/renderer/print_web_view_helper.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6/chrome/renderer/print_web_view_helper.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/print_web_view_helper.cc?ref=b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6"", ""patch"": ""@@ -713,7 +713,8 @@ PrintWebViewHelper::PrintWebViewHelper(content::RenderView* render_view)\n       user_cancelled_scripted_print_count_(0),\n       is_scripted_printing_blocked_(false),\n       notify_browser_of_print_failure_(true),\n-      print_for_preview_(false) {\n+      print_for_preview_(false),\n+      print_node_in_progress_(false) {\n }\n \n PrintWebViewHelper::~PrintWebViewHelper() {}\n@@ -1124,6 +1125,15 @@ void PrintWebViewHelper::PrintNode(const WebKit::WebNode& node) {\n     return;\n   }\n \n+  if (print_node_in_progress_) {\n+    // This can happen as a result of processing sync messages when printing\n+    // from ppapi plugins. It's a rare case, so its OK to just fail here.\n+    // See http://crbug.com/159165.\n+    return;\n+  }\n+\n+  print_node_in_progress_ = true;\n+\n   // Make a copy of the node, in case RenderView::OnContextMenuClosed resets\n   // its |context_menu_node_|.\n   if (is_preview_enabled_) {\n@@ -1133,6 +1143,8 @@ void PrintWebViewHelper::PrintNode(const WebKit::WebNode& node) {\n     WebKit::WebNode duplicate_node(node);\n     Print(duplicate_node.document().frame(), duplicate_node);\n   }\n+\n+  print_node_in_progress_ = false;\n }\n \n void PrintWebViewHelper::Print(WebKit::WebFrame* frame,""}<_**next**_>{""sha"": ""26678f47de0640355fb8fe37cb070f07c0382834"", ""filename"": ""chrome/renderer/print_web_view_helper.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6/chrome/renderer/print_web_view_helper.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6/chrome/renderer/print_web_view_helper.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/print_web_view_helper.h?ref=b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6"", ""patch"": ""@@ -488,6 +488,7 @@ class PrintWebViewHelper\n     State state_;\n   };\n \n+  bool print_node_in_progress_;\n   PrintPreviewContext print_preview_context_;\n   DISALLOW_COPY_AND_ASSIGN(PrintWebViewHelper);\n };""}","int PrintWebViewHelper::PrintPreviewContext::total_page_count() const {
  DCHECK(state_ != UNINITIALIZED);
  return total_page_count_;
}
","int PrintWebViewHelper::PrintPreviewContext::total_page_count() const {
  DCHECK(state_ != UNINITIALIZED);
  return total_page_count_;
}
",C,,,,"@@ -713,7 +713,8 @@ PrintWebViewHelper::PrintWebViewHelper(content::RenderView* render_view)
       user_cancelled_scripted_print_count_(0),
       is_scripted_printing_blocked_(false),
       notify_browser_of_print_failure_(true),
-      print_for_preview_(false) {
+      print_for_preview_(false),
+      print_node_in_progress_(false) {
 }
 
 PrintWebViewHelper::~PrintWebViewHelper() {}
@@ -1124,6 +1125,15 @@ void PrintWebViewHelper::PrintNode(const WebKit::WebNode& node) {
     return;
   }
 
+  if (print_node_in_progress_) {
+    // This can happen as a result of processing sync messages when printing
+    // from ppapi plugins. It's a rare case, so its OK to just fail here.
+    // See http://crbug.com/159165.
+    return;
+  }
+
+  print_node_in_progress_ = true;
+
   // Make a copy of the node, in case RenderView::OnContextMenuClosed resets
   // its |context_menu_node_|.
   if (is_preview_enabled_) {
@@ -1133,6 +1143,8 @@ void PrintWebViewHelper::PrintNode(const WebKit::WebNode& node) {
     WebKit::WebNode duplicate_node(node);
     Print(duplicate_node.document().frame(), duplicate_node);
   }
+
+  print_node_in_progress_ = false;
 }
 
 void PrintWebViewHelper::Print(WebKit::WebFrame* frame,",Chrome,b755ebba29dd405d6f1e4cf70f5bc81ffd33b0f6,7b688dec9fa8ab42a4933e381ad9aeb63413139b,0,"int PrintWebViewHelper::PrintPreviewContext::total_page_count() const {
  DCHECK(state_ != UNINITIALIZED);
  return total_page_count_;
}
","int PrintWebViewHelper::PrintPreviewContext::total_page_count() const {
  DCHECK(state_ != UNINITIALIZED);
  return total_page_count_;
}
",,
78906,None,Local,Not required,Complete,CVE-2018-16276,https://www.cvedetails.com/cve/CVE-2018-16276/,CWE-20,Low,Complete,Complete,,2018-08-31,7.2,An issue was discovered in yurex_read in drivers/usb/misc/yurex.c in the Linux kernel before 4.17.7. Local attackers could use user access read/writes with incorrect bounds checking in the yurex USB driver to crash the kernel or potentially escalate privileges.,2019-01-15,,0,https://github.com/torvalds/linux/commit/f1e255d60ae66a9f672ff9a207ee6cd8e33d2679,f1e255d60ae66a9f672ff9a207ee6cd8e33d2679,"USB: yurex: fix out-of-bounds uaccess in read handler

In general, accessing userspace memory beyond the length of the supplied
buffer in VFS read/write handlers can lead to both kernel memory corruption
(via kernel_read()/kernel_write(), which can e.g. be triggered via
sys_splice()) and privilege escalation inside userspace.

Fix it by using simple_read_from_buffer() instead of custom logic.

Fixes: 6bc235a2e24a (""USB: add driver for Meywa-Denki & Kayac YUREX"")
Signed-off-by: Jann Horn <jannh@google.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",0,drivers/usb/misc/yurex.c,"{""sha"": ""3be40eaa1ac9b2caf493a8fd21e8980982b5d9a1"", ""filename"": ""drivers/usb/misc/yurex.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 17, ""changes"": 23, ""blob_url"": ""https://github.com/torvalds/linux/blob/f1e255d60ae66a9f672ff9a207ee6cd8e33d2679/drivers/usb/misc/yurex.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f1e255d60ae66a9f672ff9a207ee6cd8e33d2679/drivers/usb/misc/yurex.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/misc/yurex.c?ref=f1e255d60ae66a9f672ff9a207ee6cd8e33d2679"", ""patch"": ""@@ -396,35 +396,24 @@ static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \t\t\t  loff_t *ppos)\n {\n \tstruct usb_yurex *dev;\n-\tint retval = 0;\n-\tint bytes_read = 0;\n+\tint len = 0;\n \tchar in_buffer[20];\n \tunsigned long flags;\n \n \tdev = file->private_data;\n \n \tmutex_lock(&dev->io_mutex);\n \tif (!dev->interface) {\t\t/* already disconnected */\n-\t\tretval = -ENODEV;\n-\t\tgoto exit;\n+\t\tmutex_unlock(&dev->io_mutex);\n+\t\treturn -ENODEV;\n \t}\n \n \tspin_lock_irqsave(&dev->lock, flags);\n-\tbytes_read = snprintf(in_buffer, 20, \""%lld\\n\"", dev->bbu);\n+\tlen = snprintf(in_buffer, 20, \""%lld\\n\"", dev->bbu);\n \tspin_unlock_irqrestore(&dev->lock, flags);\n-\n-\tif (*ppos < bytes_read) {\n-\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n-\t\t\tretval = -EFAULT;\n-\t\telse {\n-\t\t\tretval = bytes_read - *ppos;\n-\t\t\t*ppos += bytes_read;\n-\t\t}\n-\t}\n-\n-exit:\n \tmutex_unlock(&dev->io_mutex);\n-\treturn retval;\n+\n+\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n }\n \n static ssize_t yurex_write(struct file *file, const char __user *user_buffer,""}","static int yurex_open(struct inode *inode, struct file *file)
{
	struct usb_yurex *dev;
	struct usb_interface *interface;
	int subminor;
	int retval = 0;

	subminor = iminor(inode);

	interface = usb_find_interface(&yurex_driver, subminor);
	if (!interface) {
		printk(KERN_ERR ""%s - error, can't find device for minor %d"",
		       __func__, subminor);
		retval = -ENODEV;
		goto exit;
	}

	dev = usb_get_intfdata(interface);
	if (!dev) {
		retval = -ENODEV;
		goto exit;
	}

	/* increment our usage count for the device */
	kref_get(&dev->kref);

	/* save our object in the file's private structure */
	mutex_lock(&dev->io_mutex);
	file->private_data = dev;
	mutex_unlock(&dev->io_mutex);

exit:
	return retval;
}
","static int yurex_open(struct inode *inode, struct file *file)
{
	struct usb_yurex *dev;
	struct usb_interface *interface;
	int subminor;
	int retval = 0;

	subminor = iminor(inode);

	interface = usb_find_interface(&yurex_driver, subminor);
	if (!interface) {
		printk(KERN_ERR ""%s - error, can't find device for minor %d"",
		       __func__, subminor);
		retval = -ENODEV;
		goto exit;
	}

	dev = usb_get_intfdata(interface);
	if (!dev) {
		retval = -ENODEV;
		goto exit;
	}

	/* increment our usage count for the device */
	kref_get(&dev->kref);

	/* save our object in the file's private structure */
	mutex_lock(&dev->io_mutex);
	file->private_data = dev;
	mutex_unlock(&dev->io_mutex);

exit:
	return retval;
}
",C,,,,"@@ -396,35 +396,24 @@ static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,
 			  loff_t *ppos)
 {
 	struct usb_yurex *dev;
-	int retval = 0;
-	int bytes_read = 0;
+	int len = 0;
 	char in_buffer[20];
 	unsigned long flags;
 
 	dev = file->private_data;
 
 	mutex_lock(&dev->io_mutex);
 	if (!dev->interface) {		/* already disconnected */
-		retval = -ENODEV;
-		goto exit;
+		mutex_unlock(&dev->io_mutex);
+		return -ENODEV;
 	}
 
 	spin_lock_irqsave(&dev->lock, flags);
-	bytes_read = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);
+	len = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);
 	spin_unlock_irqrestore(&dev->lock, flags);
-
-	if (*ppos < bytes_read) {
-		if (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))
-			retval = -EFAULT;
-		else {
-			retval = bytes_read - *ppos;
-			*ppos += bytes_read;
-		}
-	}
-
-exit:
 	mutex_unlock(&dev->io_mutex);
-	return retval;
+
+	return simple_read_from_buffer(buffer, count, ppos, in_buffer, len);
 }
 
 static ssize_t yurex_write(struct file *file, const char __user *user_buffer,",linux,f1e255d60ae66a9f672ff9a207ee6cd8e33d2679,bba57eddadda936c94b5dccf73787cb9e159d0a5,0,"static int yurex_open(struct inode *inode, struct file *file)
{
	struct usb_yurex *dev;
	struct usb_interface *interface;
	int subminor;
	int retval = 0;

	subminor = iminor(inode);

	interface = usb_find_interface(&yurex_driver, subminor);
	if (!interface) {
		printk(KERN_ERR ""%s - error, can't find device for minor %d"",
		       __func__, subminor);
		retval = -ENODEV;
		goto exit;
	}

	dev = usb_get_intfdata(interface);
	if (!dev) {
		retval = -ENODEV;
		goto exit;
	}

	/* increment our usage count for the device */
	kref_get(&dev->kref);

	/* save our object in the file's private structure */
	mutex_lock(&dev->io_mutex);
	file->private_data = dev;
	mutex_unlock(&dev->io_mutex);

exit:
	return retval;
}
","static int yurex_open(struct inode *inode, struct file *file)
{
	struct usb_yurex *dev;
	struct usb_interface *interface;
	int subminor;
	int retval = 0;

	subminor = iminor(inode);

	interface = usb_find_interface(&yurex_driver, subminor);
	if (!interface) {
		printk(KERN_ERR ""%s - error, can't find device for minor %d"",
		       __func__, subminor);
		retval = -ENODEV;
		goto exit;
	}

	dev = usb_get_intfdata(interface);
	if (!dev) {
		retval = -ENODEV;
		goto exit;
	}

	/* increment our usage count for the device */
	kref_get(&dev->kref);

	/* save our object in the file's private structure */
	mutex_lock(&dev->io_mutex);
	file->private_data = dev;
	mutex_unlock(&dev->io_mutex);

exit:
	return retval;
}
",,
